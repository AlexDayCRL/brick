/**
***************************************************************************
* @file brick/computerVision/calibrationTools.hh
*
* Header file declaring utility routines for use in calibrating sensors.
*
* Copyright (C) 2009-2012 David LaRose, dlr@davidlarose.com
* See accompanying file, LICENSE.TXT, for details.
*
***************************************************************************
*/

#ifndef BRICK_COMPUTERVISION_CALIBRATIONTOOLS_HH
#define BRICK_COMPUTERVISION_CALIBRATIONTOOLS_HH

#include <brick/computerVision/cameraIntrinsicsPinhole.hh>
#include <brick/geometry/circle3D.hh>
#include <brick/numeric/transform3D.hh>

namespace brick {

  namespace computerVision {

    /**
     ** Class used to report information describing the result of a
     ** call to estimateCameraParameters().
     **/
    template <class FloatType>
    class CameraParameterEstimationStatistics {
    public:

      /**
       * Default constructor.
       */
      CameraParameterEstimationStatistics();

      /**
       * Copy constructor deep copies its argument.
       *
       * @param other This argument is the instance to be copied.
       */
      CameraParameterEstimationStatistics(
        CameraParameterEstimationStatistics const& other);

      /**
       * Destructor cleans up resources.
       */
      virtual
      ~CameraParameterEstimationStatistics();

      /**
       * The assignment operator deep copies its argument.
       *
       * @param other This argument is the instance to be copied.
       *
       * @return The return value is a reference to &this.
       */
      CameraParameterEstimationStatistics&
      operator=(CameraParameterEstimationStatistics const& other);

      /**
       * This function returns the condition number of the approximate
       * Hessian matrix of the calibration objective function,
       * evaluated at the local minimum found by
       * estimateCameraParameters.  If this number is very large, it
       * indicates that the quality of the result is not good.  Note
       * that estimateCameraParameters overparameterizes the
       * optimization by 1 degree of freedom (using an un-normalized
       * quaternion to represent rotation. For this reason, the
       * condition number is computed based on a reduced-dimension
       * version of the Hessian matrix that doesn't include the
       * unconstrained degree of freedom corresponding to quaternion
       * scale.
       *
       * @param numberOfUnconstrainedAxes This argument allows the
       * optimization to be overparameterized, for example by using a
       * non-unit quaternion to represent rotation
       *
       * @return The return value is the condition number.
       */
      FloatType
      getConditionNumber(unsigned int numberOfUnconstrainedAxes = 1);


      brick::numeric::Array1D<FloatType>
      getEigenvalues();


      brick::numeric::Array2D<FloatType>
      getEigenvectors();


      brick::numeric::Array1D<FloatType>
      getParameters();


      /**
       * This member function is called by estimateCameraParameters to
       * record calibration statistics that will later be available to
       * the user.
       *
       * @param residuals This argument is a vector of residuals from
       * nonlinear least squares optimization.
       *
       * @param parameterVector This argument is the parameter vector
       * of the nonlinear least squares optimization at the selected
       * minimum.
       *
       * @param m_hessianMatrix This argument is the estimated second
       * derivative matrix of the nonlinear least squares objective
       * function at the selected minimum.
       */
      void
      setStatistics(brick::numeric::Array1D<FloatType> residuals,
                    brick::numeric::Array1D<FloatType> parameterVector,
                    brick::numeric::Array2D<FloatType> hessianMatrix);


    protected:
      brick::numeric::Array1D<FloatType> m_residuals;
      brick::numeric::Array1D<FloatType> m_parameterVector;
      brick::numeric::Array2D<FloatType> m_hessianMatrix;
    };


    /**
     * This function estimates camera intrinsic parameters for
     * "complicated" types of camera intrinsics that require nonlinear
     * optimization.  It differs from the function
     * estimateCameraParameters() in that the 3D points must be
     * expressed in camera coordinates (i.e., the camera extrinsics
     * must already be known).  It differs from the function
     * estimateCameraIntrinsicsPinhole() in that it tries to recover
     * lens distortion parameters.  The estimation is based on
     * corresponding points in 2D image coordinates and 3D camera
     * coordinates.  If this function fails to estimate the intrinsics
     * based on the input points, it will throw ValueException.
     *
     * @param numPixelsX This argument specifies the number of columns
     * in images generated by the camera for which intrinsics are
     * being estimated.
     *
     * @param numPixelsY This argument specifies the number of columns
     * in images generated by the camera for which intrinsics are
     * being estimated.
     *
     * @param points3DBegin This argument is an iterator pointing to
     * the beginning of a sequence of 3D points (expressed as
     * brick::numeric::Vector3D<Intrinsics::FloatType> instances) in
     * camera coordinates.  The minimum length of this sequence
     * depends on the type of camera intrinsics being estimated.
     *
     * @param points3DEnd This argument is an iterator pointing one
     * element past the end of the sequence of 3D points in camera
     * coordinates (following the standard library iterator
     * convention).
     *
     * @param points2DBegin This argument is an iterator pointing to
     * the beginning of a sequence of 2D points (expressed as
     * brick::numeric::Vector2D<Intrinsics::FloatType> instances) in
     * pixel coordinates, corresponding to the the sequence defined by
     * points3DBegin and points3DEnd.  Each element of this sequence
     * must be the projection of the corresponding element of the
     * sequence of 3D points.
     *
     * @param verbosity This argument sets the level of standard
     * output generated by the function call (0 means none).
     *
     * @return The return value is an estimated camera intrinsics
     * instance that optimally (or as close as possible to optimally,
     * depending on implementation) projects the 3D points to to the
     * corresponding 2D points.
     */
    template <class Intrinsics, class Iter3D, class Iter2D>
    Intrinsics
    estimateCameraIntrinsics(unsigned int numPixelsX,
                             unsigned int numPixelsY,
                             Iter3D points3DBegin,
                             Iter3D points3DEnd,
                             Iter2D points2DBegin,
                             int verbosity = 0);


    /**
     * This function estimates pinhole camera intrinsic parameters
     * based on corresponding points in 2D image coordinates and 3D
     * camera coordinates.  It differs from the function
     * estimateCameraParametersPinhole() in that the 3D points must be
     * expressed in camera coordinates (i.e., the camera extrinsics
     * must already be known).  It differs from the function
     * estimateCameraIntrinsics() in that it does not try to recover
     * lens distortion parameters.  If it is not possible to compute a
     * valid CameraIntrinsicsPinhole instance from the input points,
     * this function will throw ValueException.
     *
     * @param numPixelsX This argument specifies the number of columns
     * in images corresponding to this pinhole camera.  It is copied
     * directly in to the return value, and does not otherwise affect
     * the operation of this function.
     *
     * @param numPixelsY This argument specifies the number of columns
     * in images corresponding to this pinhole camera.  It is copied
     * directly in to the return value, and does not otherwise affect
     * the operation of this function.
     *
     * @param points3DBegin This argument is an iterator pointing to
     * the beginning of a sequence of 3D points (expressed as
     * brick::numeric::Vector3D<Intrinsics::FloatType> instances) in
     * camera coordinates.  The sequence must contain at least 3
     * elements.
     *
     * @param points3DEnd This argument is an iterator pointing one
     * element past the end of the sequence of 3D points in camera
     * coordinates (following the standard library iterator
     * convention).
     *
     * @param points2DBegin This argument is an iterator pointing to
     * the beginning of a sequence of 2D points (expressed as
     * brick::numeric::Vector2D<Intrinsics::FloatType> instances) in
     * pixel coordinates, corresponding to the the sequence defined by
     * points3DBegin and points3DEnd.  Each element of this sequence
     * must be the projection of the corresponding element of the
     * sequence of 3D points.
     *
     * @return The return value is a CameraIntrinsicsPinhole instance
     * that optimally (in the least squares sense) projects the 3D
     * points to to the corresponding 2D points.
     */
    template <class FloatType, class Iter3D, class Iter2D>
    CameraIntrinsicsPinhole<FloatType>
    estimateCameraIntrinsicsPinhole(unsigned int numPixelsX,
                                    unsigned int numPixelsY,
                                    Iter3D points3DBegin,
                                    Iter3D points3DEnd,
                                    Iter2D points2DBegin);



    /**
     * This function estimates camera intrinsic and extrinsic
     * parameters for "complicated" types of camera intrinsics that
     * require nonlinear optimization.  It differs from the function
     * estimateCameraIntrinsics() in that the 3D points are expressed
     * in world coordinates, and the camera extrinsics (the position
     * of the camera with respect to the world) are estimated.  It
     * differs from the function estimateCameraParametersPinhole() in
     * that it tries to recover lens distortion parameters.  The
     * estimation is based on corresponding points in 2D image
     * coordinates and 3D world coordinates.  If this function fails
     * to estimate the intrinsics based on the input points, it will
     * throw ValueException.
     *
     * @param intrinsics This reference argument is used to return the
     * estimated camera intrinsics.
     *
     * @param cameraTworld This reference argument is used to return
     * the estimated coordinate transformation that takes world
     * coordinates and returns the corresponding camera coordinates.
     *
     * @param statistics This reference argument is used to return
     * information about the calibration result.
     *
     * @param numPixelsX This argument specifies the number of columns
     * in images generated by the camera for which intrinsics are
     * being estimated.
     *
     * @param numPixelsY This argument specifies the number of columns
     * in images generated by the camera for which intrinsics are
     * being estimated.
     *
     * @param points3DBegin This argument is an iterator pointing to
     * the beginning of a sequence of 3D points (expressed as
     * brick::numeric::Vector3D<Intrinsics::FloatType> instances) in
     * world coordinates.  The minimum length of this sequence depends
     * on the type of camera intrinsics being estimated.
     *
     * @param points3DEnd This argument is an iterator pointing one
     * element past the end of the sequence of 3D points in camera
     * coordinates (following the standard library iterator
     * convention).
     *
     * @param points2DBegin This argument is an iterator pointing to
     * the beginning of a sequence of 2D points (expressed as
     * brick::numeric::Vector3D<Intrinsics::FloatType> instances) in
     * pixel coordinates, corresponding to the the sequence defined by
     * points3DBegin and points3DEnd.  Each element of this sequence
     * must be the projection of the corresponding element of the
     * sequence of 3D points.
     *
     * @param verbosity This argument sets the level of standard
     * output generated by the function call (0 means none).
     */
    template <class Intrinsics, class Iter3D, class Iter2D>
    void
    estimateCameraParameters(
      Intrinsics& intrinsics,
      numeric::Transform3D<typename Intrinsics::FloatType>& cameraTworld,
      CameraParameterEstimationStatistics<typename Intrinsics::FloatType>&
        statistics,
      unsigned int numPixelsX, unsigned int numPixelsY,
      Iter3D points3DBegin, Iter3D points3DEnd,
      Iter2D points2DBegin,
      int verbosity = 0);


    /**
     * This function estimates pinhole camera intrinsic and extrinsic
     * parameters based on corresponding points in 2D image
     * coordinates and 3D world coordinates.  It differs from the
     * function estimateCameraIntrinsicsPinhole() in that the 3D
     * points are expressed in world coordinates, and the camera
     * extrinsics (the position of the camera with respect to the
     * world) are estimated.  It is also less accurate.  It differs
     * from the function estimateCameraParameters() in that it does
     * not try to recover lens distortion parameters.
     *
     * The transformation between world coordinates
     * and camera coordinates will be estimated and returned via
     * reference argument cameraTworld.  If it is not possible to
     * compute a valid CameraIntrinsicsPinhole instance from the input
     * points, this function will throw ValueException.
     *
     * @param intrinsics This reference argument is used to return the
     * estimated camera intrinsics.
     *
     * @param cameraTworld This reference argument is used to return
     * the estimated coordinate transformation that takes world
     * coordinates and returns the corresponding camera coordinates.
     *
     * @param numPixelsX This argument specifies the number of columns
     * in images corresponding to this pinhole camera.  It is copied
     * directly in to the return value, and does not otherwise affect
     * the operation of this function.
     *
     * @param numPixelsY This argument specifies the number of columns
     * in images corresponding to this pinhole camera.  It is copied
     * directly in to the return value, and does not otherwise affect
     * the operation of this function.
     *
     * @param points3DBegin This argument is an iterator pointing to
     * the beginning of a sequence of 3D points (expressed as
     * brick::numeric::Vector3D<Intrinsics::FloatType> instances) in
     * world coordinates.  The sequence must contain at least 3
     * elements.
     *
     * @param points3DEnd This argument is an iterator pointing one
     * element past the end of the sequence of 3D points in world
     * coordinates (following the standard library iterator
     * convention).
     *
     * @param points2DBegin This argument is an iterator pointing to
     * the beginning of a sequence of 2D points (expressed as
     * brick::numeric::Vector2D<Intrinsics::FloatType> instances) in
     * pixel coordinates, corresponding to the the sequence defined by
     * points3DBegin and points3DEnd.  Each element of this sequence
     * must be the projection of the corresponding element of the
     * sequence of 3D points in world coordinates.
     */
    template <class FloatType, class Iter3D, class Iter2D>
    void
    estimateCameraParametersPinhole(
      CameraIntrinsicsPinhole<FloatType>& intrinsics,
      numeric::Transform3D<FloatType>& cameraTworld,
      unsigned int numPixelsX,
      unsigned int numPixelsY,
      Iter3D points3DBegin,
      Iter3D points3DEnd,
      Iter2D points2DBegin);


    /**
     * This function estimates the centroid, in pixel coordinates, of
     * the projection of a circular target into the image, accounting
     * for perspective effects and lens distortion.
     *
     * @param target This argument describes the target to be
     * projected.  It is a flat circular target in 3D camera
     * coordinates, with no constraints on position or orientation.
     *
     * @param intrinsics This argument describes the camera
     * projection, includingn lens distortion.
     *
     * @param numberOfTriangles The circle will be approximated by
     * this many "pie slice" triangles.  Higher numbers mean better
     * precision, but more computation.  The default value makes the
     * area of the approximation be about 99% of the area of the
     * circle.  The error in centroid position, of course, depends on
     * the camera projection.
     *
     * @return The return value is the estimated centroid in pixel
     * coordinates.
     */
    template <class Intrinsics>
    void
    estimateProjectedAreaAndCentroid(
      typename Intrinsics::FloatType& area,
      numeric::Vector2D<typename Intrinsics::FloatType>& centroid,
      geometry::Circle3D<typename Intrinsics::FloatType> const& target,
      Intrinsics const& intrinsics,
      common::UInt32 numberOfTriangles = 80);

  } // namespace computerVision

} // namespace brick


// Include file containing definitions of inline and template
// functions.
#include <brick/computerVision/calibrationTools_impl.hh>

#endif /* #ifndef BRICK_COMPUTERVISION_CALIBRATIONTOOLS_HH */
